├── .cargo
    └── config.toml
├── .gitignore
├── Cargo.toml
├── LICENSE
├── README.md
├── tokio_with_wasm
    ├── Cargo.toml
    ├── README.md
    └── src
    │   ├── glue
    │       ├── common.rs
    │       ├── mod.rs
    │       ├── task
    │       │   ├── mod.rs
    │       │   └── pool.rs
    │       └── time
    │       │   └── mod.rs
    │   └── lib.rs
└── tokio_with_wasm_proc
    ├── Cargo.toml
    ├── README.md
    └── src
        └── lib.rs


/.cargo/config.toml:
-----------------------

[build]
# Uncomment the line below to switch Rust-analyzer to perform
# type checking and linting in webassembly mode, for the web target.
# You might have to restart Rust-analyzer for this change to take effect.
target = "wasm32-unknown-unknown"


-----------------------

/.gitignore:
-----------------------

# Generated by Cargo
# will have compiled files and executables
debug/
target/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb


-----------------------

/Cargo.toml:
-----------------------

[workspace]
members = ["tokio_with_wasm", "tokio_with_wasm_proc"]
resolver = "2"

[patch.crates-io]
tokio_with_wasm_proc = { path = "./tokio_with_wasm_proc" }


-----------------------

/LICENSE:
-----------------------

MIT License

Copyright (c) 2014 Alex Crichton
Copyright (c) 2023 Cunarist

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


-----------------------

/README.md:
-----------------------

# tokio_with_wasm

[![Crates.io](https://img.shields.io/crates/v/tokio_with_wasm.svg)](https://crates.io/crates/tokio_with_wasm)
[![Documentation](https://docs.rs/tokio_with_wasm/badge.svg)](https://docs.rs/tokio_with_wasm)
[![License](https://img.shields.io/crates/l/tokio_with_wasm.svg)](https://github.com/cunarist/tokio-with-wasm/blob/main/LICENSE)

![Recording](https://github.com/cunarist/tokio-with-wasm/assets/66480156/77fa5838-23c7-4e3b-b1ba-61146972c2aa)

> Tested with [Rinf](https://github.com/cunarist/rinf)

tokio_with_wasm is a Rust library that provides tokio specifically designed for web browsers. It aims to provide the exact same tokio features for web applications, leveraging JavaScript web API.

This library is made up of JavaScript glue code that mimics the behavior of real tokio. Because tokio_with_wasm doesn't have its own runtime and adapts to the JavaScript event loop, advanced features of tokio might not work.

When using spawn_blocking(), the number of web workers are automatically adjusted adapting to the number of parallel tasks. Refer to the docs for additional details.

This library assumes that you're compilng your Rust project with wasm-pack and wasm-bindgen, which currently uses wasm32-unknown-unknown Rust target. Note that this library currently only supports the web target of wasm-bindgen, not [others](https://rustwasm.github.io/wasm-bindgen/reference/deployment.html) such as no-modules.

## Features

- **Familiar API**: If you're familiar with tokio, you'll feel right at home with tokio_with_wasm. It provides similar functionality and follows the same patterns for spawning and managing asynchronous tasks.

- **Web Worker Integration**: tokio_with_wasm adapts to the JavaScript environment by utilizing web API under the hood. This means you can write Rust code that runs concurrently and efficiently in web applications.

- **Spawn Async and Blocking Tasks**: You can spawn both asynchronous and blocking tasks. Asynchronous tasks allow you to perform non-blocking operations, while blocking tasks are suitable for compute-heavy or synchronous tasks.

> Though various IO functionalities can be added in the future, they're not included yet.

## Usage

Add this library to your Cargo.toml alongside tokio:

toml
[dependencies]
tokio = { version = "0.0.0", features = ["rt"] }
tokio_with_wasm = { version = "0.0.0", features = ["rt"] }


Here's a simple example of how to use tokio_with_wasm:

rust
use tokio_with_wasm::alias as tokio;

#[tokio::main(flavor = "current_thread")]
async fn main() {
    let async_join_handle = tokio::spawn(async {
        // Your asynchronous code here.
        // This will run concurrently
        // in the same web worker(thread).
    });
    let blocking_join_handle = tokio::task::spawn_blocking(|| {
        // Your blocking code here.
        // This will run parallelly
        // in the external pool of web workers.
    });
    let async_result = async_join_handle.await;
    let blocking_result = blocking_join_handle.await;
    for i in 1..1000 {
        // Some repeating task here
        // that shouldn't block the JavaScript runtime.
        tokio::task::yield_now().await;
    }
}


The use tokio_with_wasm::alias as tokio; statement is functionally equivalent to the code below. This import is provided for convenience and to allow for shorter code.

rust
#[cfg(all(
    target_arch = "wasm32",
    target_vendor = "unknown",
    target_os = "unknown"
))]
use tokio_with_wasm as tokio;

#[cfg(not(all(
    target_arch = "wasm32",
    target_vendor = "unknown",
    target_os = "unknown"
)))]
use tokio;


## Documentation

API documentation can be found on [docs.rs](https://docs.rs/tokio_with_wasm).

## Caution

Keep in mind that you should NEVER write panicking code.

On wasm32-unknown-unknown, there's currently [no way](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.future_to_promise.html#panics) to catch and unwind panics like on native platforms. Panics will eventually lead to leaked JavaScript Promises.

Stick to the Result enum whenever possible.

## Building and Deploying

If you're using Web Workers (threads) by calling spawn_blocking, you need to set specific Rust compiler flags:

- +atomics
- +bulk-memory
- +mutable-globals

After building your webassembly module and preparing it for deployment, ensure that your web server is configured to include cross-origin-related HTTP headers in its responses. Set the [Cross-Origin-Opener-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy) to same-origin and [Cross-Origin-Embedder-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy) to require-corp. These headers enable clients using your website to gain access to SharedArrayBuffer web API, which is something similar to shared memory on the web. Additionally, don't forget to specify the MIME type application/wasm for .wasm files within the server configurations to ensure optimal performance.

## Why This is Needed

The web has many restrictions due to its sandboxed environment which prevents the use of threads, time, file IO, network IO, and many other native functionalities. Consequently, certain features are missing from Rust's std due to these limitations. That's why tokio doesn't really work well on web browsers.

To address this issue, this crate offers tokio modules with the **same names** as the original native ones, providing workarounds for these constraints.

## Future Vision

Because a large portion of Rust's web ecosystem is based on wasm32-unknown-unknown right now, we had to make an alias crate of tokio to use its functionalities directly on the web.

Hopefully, when wasm32-wasi becomes the mainstream Rust target for the web, [jco](https://github.com/bytecodealliance/jco) might be an alternative to wasm-bindgen as it can provide full std functionalities with browser shims (polyfills). However, this will take time because the [wasi-threads](https://github.com/WebAssembly/wasi-threads) proposal still has a long way to go.

Until that time, there's tokio_with_wasm!

## Contribution Guide

Contributions are always welcome! If you have any suggestions, bug reports, or want to contribute to the development of tokio_with_wasm, please open an issue or submit a pull request.

There are situations where you cannot use native Rust code directly on the web. This is because wasm32-unknown-unknown Rust target used by wasm-bindgen doesn't have a full std module. Refer to the links below to understand how to interact with JavaScript with wasm-bindgen.

- https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/js_name.html
- https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/js_namespace.html

It is possible for rust code to be called in a **web worker**. Therefore, we cannot access the global window JavaScript object
just like when you work in the main thread of JavaScript. Refer to the link below to check which web APIs are available in a web worker.
You'll be surprised by various capabilities that modern JavaScript has.

- https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers

Please note that this library uses a quite hacky and naive approach to mimic native tokio functionalities. That's because this library is regarded as a temporary solution for the period before wasm32-wasi. Any kind of PR is possible, as long as it makes things just work on the web.


-----------------------

/tokio_with_wasm/Cargo.toml:
-----------------------

[package]
name = "tokio_with_wasm"
version = "0.7.1"
edition = "2021"
license = "MIT"
description = "Mimicking tokio functionalies on web browsers"
repository = "https://github.com/cunarist/tokio-with-wasm"

[package.metadata.docs.rs]
default-target = "wasm32-unknown-unknown"
all-features = true

[features]
# https://github.com/tokio-rs/tokio/blob/master/tokio/Cargo.toml
default = []
full = ["macros", "sync", "time", "rt", "rt-multi-thread"]
macros = ["tokio/macros"]
sync = ["tokio/sync"]
time = []
rt = []
rt-multi-thread = []

[dependencies]
tokio_with_wasm_proc = "0.7.1"
tokio = "1.x.x"
wasm-bindgen = "0.2.93"
wasm-bindgen-futures = "0.4.43"
js-sys = "0.3.70"
web-sys = { version = "0.3.70", features = [
    'Worker',
    'WorkerOptions',
    'WorkerType',
    'DedicatedWorkerGlobalScope',
    'MessageEvent',
    'ErrorEvent',
    'Blob',
    "BlobPropertyBag",
    'Url',
] }


-----------------------

/tokio_with_wasm/README.md:
-----------------------

# tokio_with_wasm

[![Crates.io](https://img.shields.io/crates/v/tokio_with_wasm.svg)](https://crates.io/crates/tokio_with_wasm)
[![Documentation](https://docs.rs/tokio_with_wasm/badge.svg)](https://docs.rs/tokio_with_wasm)
[![License](https://img.shields.io/crates/l/tokio_with_wasm.svg)](https://github.com/cunarist/tokio-with-wasm/blob/main/LICENSE)

![Recording](https://github.com/cunarist/tokio-with-wasm/assets/66480156/77fa5838-23c7-4e3b-b1ba-61146972c2aa)

> Tested with [Rinf](https://github.com/cunarist/rinf)

tokio_with_wasm is a Rust library that provides tokio specifically designed for web browsers. It aims to provide the exact same tokio features for web applications, leveraging JavaScript web API.

This library is made up of JavaScript glue code that mimics the behavior of real tokio. Because tokio_with_wasm doesn't have its own runtime and adapts to the JavaScript event loop, advanced features of tokio might not work.

When using spawn_blocking(), the number of web workers are automatically adjusted adapting to the number of parallel tasks. Refer to the docs for additional details.

This library assumes that you're compilng your Rust project with wasm-pack and wasm-bindgen, which currently uses wasm32-unknown-unknown Rust target. Note that this library currently only supports the web target of wasm-bindgen, not [others](https://rustwasm.github.io/wasm-bindgen/reference/deployment.html) such as no-modules.

## Features

- **Familiar API**: If you're familiar with tokio, you'll feel right at home with tokio_with_wasm. It provides similar functionality and follows the same patterns for spawning and managing asynchronous tasks.

- **Web Worker Integration**: tokio_with_wasm adapts to the JavaScript environment by utilizing web API under the hood. This means you can write Rust code that runs concurrently and efficiently in web applications.

- **Spawn Async and Blocking Tasks**: You can spawn both asynchronous and blocking tasks. Asynchronous tasks allow you to perform non-blocking operations, while blocking tasks are suitable for compute-heavy or synchronous tasks.

> Though various IO functionalities can be added in the future, they're not included yet.

## Usage

Add this library to your Cargo.toml alongside tokio:

toml
[dependencies]
tokio = { version = "0.0.0", features = ["rt"] }
tokio_with_wasm = { version = "0.0.0", features = ["rt"] }


Here's a simple example of how to use tokio_with_wasm:

rust
use tokio_with_wasm::alias as tokio;

#[tokio::main(flavor = "current_thread")]
async fn main() {
    let async_join_handle = tokio::spawn(async {
        // Your asynchronous code here.
        // This will run concurrently
        // in the same web worker(thread).
    });
    let blocking_join_handle = tokio::task::spawn_blocking(|| {
        // Your blocking code here.
        // This will run parallelly
        // in the external pool of web workers.
    });
    let async_result = async_join_handle.await;
    let blocking_result = blocking_join_handle.await;
    for i in 1..1000 {
        // Some repeating task here
        // that shouldn't block the JavaScript runtime.
        tokio::task::yield_now().await;
    }
}


The use tokio_with_wasm::alias as tokio; statement is functionally equivalent to the code below. This import is provided for convenience and to allow for shorter code.

rust
#[cfg(all(
    target_arch = "wasm32",
    target_vendor = "unknown",
    target_os = "unknown"
))]
use tokio_with_wasm as tokio;

#[cfg(not(all(
    target_arch = "wasm32",
    target_vendor = "unknown",
    target_os = "unknown"
)))]
use tokio;


## Documentation

API documentation can be found on [docs.rs](https://docs.rs/tokio_with_wasm).

## Caution

Keep in mind that you should NEVER write panicking code.

On wasm32-unknown-unknown, there's currently [no way](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.future_to_promise.html#panics) to catch and unwind panics like on native platforms. Panics will eventually lead to leaked JavaScript Promises.

Stick to the Result enum whenever possible.

## Building and Deploying

If you're using Web Workers (threads) by calling spawn_blocking, you need to set specific Rust compiler flags:

- +atomics
- +bulk-memory
- +mutable-globals

After building your webassembly module and preparing it for deployment, ensure that your web server is configured to include cross-origin-related HTTP headers in its responses. Set the [Cross-Origin-Opener-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy) to same-origin and [Cross-Origin-Embedder-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy) to require-corp. These headers enable clients using your website to gain access to SharedArrayBuffer web API, which is something similar to shared memory on the web. Additionally, don't forget to specify the MIME type application/wasm for .wasm files within the server configurations to ensure optimal performance.

## Why This is Needed

The web has many restrictions due to its sandboxed environment which prevents the use of threads, time, file IO, network IO, and many other native functionalities. Consequently, certain features are missing from Rust's std due to these limitations. That's why tokio doesn't really work well on web browsers.

To address this issue, this crate offers tokio modules with the **same names** as the original native ones, providing workarounds for these constraints.

## Future Vision

Because a large portion of Rust's web ecosystem is based on wasm32-unknown-unknown right now, we had to make an alias crate of tokio to use its functionalities directly on the web.

Hopefully, when wasm32-wasi becomes the mainstream Rust target for the web, [jco](https://github.com/bytecodealliance/jco) might be an alternative to wasm-bindgen as it can provide full std functionalities with browser shims (polyfills). However, this will take time because the [wasi-threads](https://github.com/WebAssembly/wasi-threads) proposal still has a long way to go.

Until that time, there's tokio_with_wasm!

## Contribution Guide

Contributions are always welcome! If you have any suggestions, bug reports, or want to contribute to the development of tokio_with_wasm, please open an issue or submit a pull request.

There are situations where you cannot use native Rust code directly on the web. This is because wasm32-unknown-unknown Rust target used by wasm-bindgen doesn't have a full std module. Refer to the links below to understand how to interact with JavaScript with wasm-bindgen.

- https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/js_name.html
- https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/js_namespace.html

It is possible for rust code to be called in a **web worker**. Therefore, we cannot access the global window JavaScript object
just like when you work in the main thread of JavaScript. Refer to the link below to check which web APIs are available in a web worker.
You'll be surprised by various capabilities that modern JavaScript has.

- https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers

Please note that this library uses a quite hacky and naive approach to mimic native tokio functionalities. That's because this library is regarded as a temporary solution for the period before wasm32-wasi. Any kind of PR is possible, as long as it makes things just work on the web.


-----------------------

/tokio_with_wasm/src/glue/common.rs:
-----------------------

#![allow(unused_macros, unused_imports, dead_code)]

use std::future::Future;
use std::pin::Pin;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::{Arc, Mutex};
use std::task::{Context, Poll, Waker};
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console, js_name = error)]
    pub fn error(s: &str);
    #[wasm_bindgen(js_namespace = Date, js_name = now)]
    pub fn now() -> f64;
    #[wasm_bindgen(js_name = setTimeout)]
    pub fn set_timeout(callback: &js_sys::Function, milliseconds: f64);
}

macro_rules! console_error {
    ($($t:tt)*) => (error(&format_args!($($t)*).to_string()))
}
pub(crate) use console_error;

pub type Result<T> = std::result::Result<T, JsValue>;

pub struct SelectFuture<T> {
    future_a: Pin<Box<dyn Future<Output = T>>>,
    future_b: Pin<Box<dyn Future<Output = T>>>,
}

impl<T> SelectFuture<T> {
    pub fn new(
        future_a: impl Future<Output = T> + 'static,
        future_b: impl Future<Output = T> + 'static,
    ) -> Self {
        SelectFuture {
            future_a: Box::pin(future_a),
            future_b: Box::pin(future_b),
        }
    }
}

impl<T> Future for SelectFuture<T> {
    type Output = T;
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        if let Poll::Ready(output) = self.future_a.as_mut().poll(cx) {
            return Poll::Ready(output);
        }
        if let Poll::Ready(output) = self.future_b.as_mut().poll(cx) {
            return Poll::Ready(output);
        }
        Poll::Pending
    }
}

pub fn once_channel<T>() -> (OnceSender<T>, OnceReceiver<T>) {
    let notified = Arc::new(AtomicBool::new(false));
    let value = Arc::new(Mutex::new(None));
    let waker = Arc::new(Mutex::new(None));

    let sender = OnceSender {
        notified: notified.clone(),
        value: value.clone(),
        waker: waker.clone(),
    };
    let receiver = OnceReceiver {
        notified,
        value,
        waker,
    };

    (sender, receiver)
}

pub struct OnceSender<T> {
    notified: Arc<AtomicBool>,
    value: Arc<Mutex<Option<T>>>,
    waker: Arc<Mutex<Option<Waker>>>,
}

impl<T> OnceSender<T> {
    pub fn send(&self, value: T) {
        if let Ok(mut guard) = self.value.lock() {
            guard.replace(value);
            self.notified.store(true, Ordering::SeqCst);
        }
        if let Ok(mut guard) = self.waker.lock() {
            if let Some(waker) = guard.take() {
                waker.wake();
            }
        }
    }
}

pub struct OnceReceiver<T> {
    notified: Arc<AtomicBool>,
    value: Arc<Mutex<Option<T>>>,
    waker: Arc<Mutex<Option<Waker>>>,
}

impl<T> OnceReceiver<T> {
    pub fn is_done(&self) -> bool {
        self.notified.load(Ordering::SeqCst)
    }
}

impl<T> Future for OnceReceiver<T> {
    type Output = T;
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        if self.notified.load(Ordering::SeqCst) {
            if let Ok(mut guard) = self.value.lock() {
                if let Some(value) = guard.take() {
                    return Poll::Ready(value);
                }
            }
        }
        if let Ok(mut guard) = self.waker.lock() {
            guard.replace(cx.waker().clone());
        }
        Poll::Pending
    }
}


-----------------------

/tokio_with_wasm/src/glue/mod.rs:
-----------------------

//! JavaScript glue module that mimics tokio.

mod common;

#[cfg(feature = "macros")]
pub use tokio::{join, pin, select, try_join};

#[cfg(feature = "sync")]
pub use tokio::sync;

#[cfg(feature = "time")]
pub mod time;

#[cfg(feature = "rt")]
pub mod task;
#[cfg(feature = "rt")]
pub use task::spawn;

#[cfg(all(any(feature = "rt", feature = "rt-multi-thread"), feature = "macros"))]
pub use tokio_with_wasm_proc::main;
#[doc(hidden)]
#[cfg(all(any(feature = "rt", feature = "rt-multi-thread"), feature = "macros"))]
pub use wasm_bindgen_futures::spawn_local;


-----------------------

/tokio_with_wasm/src/glue/task/mod.rs:
-----------------------

/tokio_with_wasm/src/glue/task/pool.rs:
-----------------------

use crate::glue::common::*;
use js_sys::Array;
use std::cell::RefCell;
use std::collections::VecDeque;
use std::rc::Rc;
use wasm_bindgen::prelude::*;
use web_sys::{
    Blob, BlobPropertyBag, DedicatedWorkerGlobalScope, ErrorEvent, Event, MessageEvent, Url,
    Worker, WorkerOptions,
};

pub static MAX_WORKERS: usize = 512;

#[wasm_bindgen]
pub struct WorkerPool {
    pool_state: Rc<PoolState>,
}

struct PoolState {
    total_workers_count: RefCell<usize>,
    idle_workers: RefCell<Vec<ManagedWorker>>,
    queued_tasks: RefCell<VecDeque<Task>>,
    callback: Closure<dyn FnMut(Event)>,
}

struct ManagedWorker {
    deactivated_time: RefCell<f64>, // Timestamp in milliseconds
    worker: Worker,
}

struct Task {
    callable: Box<dyn FnOnce() + Send>,
}

impl Default for WorkerPool {
    fn default() -> Self {
        WorkerPool {
            pool_state: Rc::new(PoolState {
                total_workers_count: RefCell::new(0),
                idle_workers: RefCell::new(Vec::with_capacity(MAX_WORKERS)),
                queued_tasks: RefCell::new(VecDeque::new()),
                callback: Closure::new(|event: Event| {
                    console_error!("unhandled event: {:?}", event);
                }),
            }),
        }
    }
}

#[wasm_bindgen]
impl WorkerPool {
    /// Creates a new WorkerPool which immediately creates initial workers.
    ///
    /// The pool created here can be used over a long period of time, and it
    /// will be initially primed with initial workers. Currently workers are
    /// never released or gc'd until the whole pool is destroyed.
    ///
    /// # Errors
    ///
    /// Returns any error that may happen while a JS web worker is created and a
    /// message is sent to it.
    #[wasm_bindgen(constructor)]
    pub fn new() -> WorkerPool {
        WorkerPool::default()
    }

    /// Unconditionally spawns a new worker
    ///
    /// The worker isn't registered with this WorkerPool but is capable of
    /// executing work for this wasm module.
    ///
    /// # Errors
    ///
    /// Returns any error that may happen while a JS web worker is created and a
    /// message is sent to it.
    fn create_worker(&self) -> Result<Worker> {
        *self.pool_state.total_workers_count.borrow_mut() += 1;
        let script = format!(
            "
            import init, * as wasm_bindgen from '{}';
            globalThis.wasm_bindgen = wasm_bindgen;
            self.onmessage = event => {{
                let initialised = init(event.data).catch(err => {{
                    // Propagate to main onerror:
                    setTimeout(() => {{
                        throw err;
                    }});
                    // Rethrow to keep promise rejected and prevent execution of further commands:
                    throw err;
                }});

                self.onmessage = async event => {{
                    // This will queue further commands up until the module is fully initialised:
                    await initialised;
                    wasm_bindgen.task_worker_entry_point(event.data);
                }};
            }};
            ",
            get_script_path()?
        );
        let blob_property_bag = BlobPropertyBag::new();
        blob_property_bag.set_type("text/javascript");
        let blob = Blob::new_with_blob_sequence_and_options(
            &Array::from_iter([JsValue::from(script)]).into(),
            &blob_property_bag,
        )?;
        let url = Url::create_object_url_with_blob(&blob)?;
        let options = WorkerOptions::new();
        options.set_type(web_sys::WorkerType::Module);
        let worker = Worker::new_with_options(&url, &options)?;

        // With a worker spun up send it the module/memory so it can start
        // instantiating the wasm module. Later it might receive further
        // messages about code to run on the wasm module.
        let worker_init = js_sys::Object::new();
        js_sys::Reflect::set(
            &worker_init,
            &js_sys::JsString::from("module_or_path"),
            &wasm_bindgen::module(),
        )?;
        js_sys::Reflect::set(
            &worker_init,
            &js_sys::JsString::from("memory"),
            &wasm_bindgen::memory(),
        )?;
        worker.post_message(&worker_init)?;

        Ok(worker)
    }

    /// Fetches a worker from this pool, creating one if necessary.
    ///
    /// This will attempt to pull an already-spawned web worker from our cache
    /// if one is available, otherwise it will spawn a new worker and return the
    /// newly spawned worker.
    ///
    /// # Errors
    ///
    /// Returns any error that may happen while a JS web worker is created and a
    /// message is sent to it.
    fn get_worker(&self) -> Result<Worker> {
        if let Some(managed_worker) = self.pool_state.idle_workers.borrow_mut().pop() {
            Ok(managed_worker.worker)
        } else {
            self.create_worker()
        }
    }

    /// Executes the work f in a web worker, spawning a web worker if
    /// necessary.
    ///
    /// This will acquire a web worker and then send the closure f to the
    /// worker to execute. The worker won't be usable for anything else while
    /// f is executing, and no callbacks are registered for when the worker
    /// finishes.
    ///
    /// # Errors
    ///
    /// Returns any error that may happen while a JS web worker is created and a
    /// message is sent to it.
    fn execute(&self, task: Task) -> Result<Worker> {
        let worker = self.get_worker()?;
        let work = Box::new(task);
        let ptr = Box::into_raw(work);
        match worker.post_message(&JsValue::from(ptr as u32)) {
            Ok(()) => Ok(worker),
            Err(error) => {
                unsafe {
                    drop(Box::from_raw(ptr));
                }
                Err(error)
            }
        }
    }

    /// Configures an onmessage callback for the worker specified for the
    /// web worker to be reclaimed and re-inserted into this pool when a message
    /// is received.
    ///
    /// Currently this WorkerPool abstraction is intended to execute one-off
    /// style work where the work itself doesn't send any notifications and
    /// whatn it's done the worker is ready to execute more work. This method is
    /// used for all spawned workers to ensure that when the work is finished
    /// the worker is reclaimed back into this pool.
    fn reclaim_on_message(&self, worker: Worker) {
        let pool_state = Rc::downgrade(&self.pool_state);
        let worker2 = worker.clone();
        let reclaim_slot = Rc::new(RefCell::new(None));
        let slot2 = reclaim_slot.clone();
        let reclaim = Closure::<dyn FnMut(_)>::new(move |event: Event| {
            if let Some(error) = event.dyn_ref::<ErrorEvent>() {
                console_error!("Error in worker: {}", error.message());
                // TODO: this probably leaks memory somehow? It's sort of
                // unclear what to do about errors in workers right now.
                return;
            }

            // If this is a completion event then can deallocate our own
            // callback by clearing out slot2 which contains our own closure.
            if let Some(_msg) = event.dyn_ref::<MessageEvent>() {
                if let Some(pool_state) = pool_state.upgrade() {
                    pool_state.push_worker(worker2.clone());
                }
                *slot2.borrow_mut() = None;
                return;
            }

            console_error!("Unhandled event: {:?}", event);
        });
        worker.set_onmessage(Some(reclaim.as_ref().unchecked_ref()));
        *reclaim_slot.borrow_mut() = Some(reclaim);
    }
}

impl WorkerPool {
    /// Executes f in a web worker.
    ///
    /// This pool manages a set of web workers to draw from, and f will be
    /// spawned quickly into one if the worker is idle. If no idle workers are
    /// available then a new web worker will be spawned.
    ///
    /// Once f returns the worker assigned to f is automatically reclaimed
    /// by this WorkerPool. This method provides no method of learning when
    /// f completes, and for that you'll need to use run_notify.
    ///
    /// # Errors
    ///
    /// If an error happens while spawning a web worker or sending a message to
    /// a web worker, that error is returned.
    fn run(&self, task: Task) -> Result<()> {
        let worker = self.execute(task)?;
        self.reclaim_on_message(worker);
        Ok(())
    }

    pub fn remove_inactive_workers(&self) {
        let mut idle_workers = self.pool_state.idle_workers.borrow_mut();
        let current_timestamp = now();
        idle_workers.retain(|managed_worker| {
            let passed_time = current_timestamp - *managed_worker.deactivated_time.borrow();
            let is_active = passed_time < 10000.0; // 10 seconds
            if !is_active {
                managed_worker.worker.terminate();
                *self.pool_state.total_workers_count.borrow_mut() -= 1;
            }
            is_active
        });
    }

    pub fn flush_queued_tasks(&self) {
        while *self.pool_state.total_workers_count.borrow() < MAX_WORKERS {
            let mut queued_tasks = self.pool_state.queued_tasks.borrow_mut();
            if let Some(queued_task) = queued_tasks.pop_front() {
                let result = self.run(queued_task);
                if let Err(error) = result {
                    console_error!(
                        "Error from flush_queued_tasks in tokio-with-wasm: {error:?}"
                    );
                }
            } else {
                break;
            }
        }
    }

    pub fn queue_task(&self, callable: impl FnOnce() + Send + 'static) {
        let mut queued_tasks = self.pool_state.queued_tasks.borrow_mut();
        queued_tasks.push_back(Task {
            callable: Box::new(callable),
        });
        drop(queued_tasks);
        self.flush_queued_tasks();
    }
}

impl PoolState {
    fn push_worker(&self, worker: Worker) {
        worker.set_onmessage(Some(self.callback.as_ref().unchecked_ref()));
        worker.set_onerror(Some(self.callback.as_ref().unchecked_ref()));
        let mut workers = self.idle_workers.borrow_mut();
        for prev in workers.iter() {
            let prev: &JsValue = &prev.worker;
            let worker: &JsValue = &worker;
            assert!(prev != worker);
        }
        workers.push(ManagedWorker {
            deactivated_time: RefCell::new(now()),
            worker,
        });
    }
}

/// Entry point invoked by JavaScript in a worker.
#[wasm_bindgen]
pub fn task_worker_entry_point(ptr: u32) -> Result<()> {
    let ptr = unsafe { Box::from_raw(ptr as *mut Task) };
    let global = js_sys::global().unchecked_into::<DedicatedWorkerGlobalScope>();
    (ptr.callable)();
    global.post_message(&JsValue::undefined())?;
    Ok(())
}

pub fn get_script_path() -> Result<String> {
    let string = js_sys::eval(
        r"
        (() => {
            try {
                throw new Error();
            } catch (e) {
                let parts = e.stack.match(/(?:\(|@)(\S+):\d+:\d+/);
                return parts[1];
            }
        })()
        ",
    )?
    .as_string()
    .ok_or(JsValue::from(
        "Could not convert JS string path to native string",
    ))?;
    Ok(string)
}


-----------------------

/tokio_with_wasm/src/glue/time/mod.rs:
-----------------------

/tokio_with_wasm/src/lib.rs:
-----------------------

//! A library that adapts the popular async runtime tokio for web browsers.
//!
//! It provides a similar set of features specifically for web applications
//! by leveraging the JavaScript web API.
//!
//! This library includes JavaScript glue code
//! to mimic the behavior of real tokio,
//! making it possible to run asynchronous Rust code in the browser.
//! Since tokio_with_wasm adapts to the JavaScript event loop
//! and does not include its own runtime,
//! some advanced features of tokio might not be fully supported.

#![allow(unused_imports)]

#[cfg(not(all(
    target_arch = "wasm32",
    target_vendor = "unknown",
    target_os = "unknown"
)))]
pub use tokio as alias;

#[cfg(all(
    target_arch = "wasm32",
    target_vendor = "unknown",
    target_os = "unknown"
))]
pub use crate as alias;

#[cfg(all(
    target_arch = "wasm32",
    target_vendor = "unknown",
    target_os = "unknown"
))]
mod glue;

#[cfg(all(
    target_arch = "wasm32",
    target_vendor = "unknown",
    target_os = "unknown"
))]
pub use glue::*;


-----------------------

/tokio_with_wasm_proc/Cargo.toml:
-----------------------

[package]
name = "tokio_with_wasm_proc"
version = "0.7.1"
edition = "2021"
license = "MIT"
description = "Mimicking tokio functionalies on web browsers"
repository = "https://github.com/cunarist/tokio-with-wasm"

[package.metadata.docs.rs]
default-target = "wasm32-unknown-unknown"
all-features = true

[lib]
proc-macro = true

[dependencies]
syn = { version = "2.0.77", features = ["full"] }
quote = "1.0.37"


-----------------------

/tokio_with_wasm_proc/README.md:
-----------------------

# tokio_with_wasm

[![Crates.io](https://img.shields.io/crates/v/tokio_with_wasm.svg)](https://crates.io/crates/tokio_with_wasm)
[![Documentation](https://docs.rs/tokio_with_wasm/badge.svg)](https://docs.rs/tokio_with_wasm)
[![License](https://img.shields.io/crates/l/tokio_with_wasm.svg)](https://github.com/cunarist/tokio-with-wasm/blob/main/LICENSE)

![Recording](https://github.com/cunarist/tokio-with-wasm/assets/66480156/77fa5838-23c7-4e3b-b1ba-61146972c2aa)

> Tested with [Rinf](https://github.com/cunarist/rinf)

tokio_with_wasm is a Rust library that provides tokio specifically designed for web browsers. It aims to provide the exact same tokio features for web applications, leveraging JavaScript web API.

This library is made up of JavaScript glue code that mimics the behavior of real tokio. Because tokio_with_wasm doesn't have its own runtime and adapts to the JavaScript event loop, advanced features of tokio might not work.

When using spawn_blocking(), the number of web workers are automatically adjusted adapting to the number of parallel tasks. Refer to the docs for additional details.

This library assumes that you're compilng your Rust project with wasm-pack and wasm-bindgen, which currently uses wasm32-unknown-unknown Rust target. Note that this library currently only supports the web target of wasm-bindgen, not [others](https://rustwasm.github.io/wasm-bindgen/reference/deployment.html) such as no-modules.

## Features

- **Familiar API**: If you're familiar with tokio, you'll feel right at home with tokio_with_wasm. It provides similar functionality and follows the same patterns for spawning and managing asynchronous tasks.

- **Web Worker Integration**: tokio_with_wasm adapts to the JavaScript environment by utilizing web API under the hood. This means you can write Rust code that runs concurrently and efficiently in web applications.

- **Spawn Async and Blocking Tasks**: You can spawn both asynchronous and blocking tasks. Asynchronous tasks allow you to perform non-blocking operations, while blocking tasks are suitable for compute-heavy or synchronous tasks.

> Though various IO functionalities can be added in the future, they're not included yet.

## Usage

Add this library to your Cargo.toml alongside tokio:

toml
[dependencies]
tokio = { version = "0.0.0", features = ["rt"] }
tokio_with_wasm = { version = "0.0.0", features = ["rt"] }


Here's a simple example of how to use tokio_with_wasm:

rust
use tokio_with_wasm::alias as tokio;

#[tokio::main(flavor = "current_thread")]
async fn main() {
    let async_join_handle = tokio::spawn(async {
        // Your asynchronous code here.
        // This will run concurrently
        // in the same web worker(thread).
    });
    let blocking_join_handle = tokio::task::spawn_blocking(|| {
        // Your blocking code here.
        // This will run parallelly
        // in the external pool of web workers.
    });
    let async_result = async_join_handle.await;
    let blocking_result = blocking_join_handle.await;
    for i in 1..1000 {
        // Some repeating task here
        // that shouldn't block the JavaScript runtime.
        tokio::task::yield_now().await;
    }
}


The use tokio_with_wasm::alias as tokio; statement is functionally equivalent to the code below. This import is provided for convenience and to allow for shorter code.

rust
#[cfg(all(
    target_arch = "wasm32",
    target_vendor = "unknown",
    target_os = "unknown"
))]
use tokio_with_wasm as tokio;

#[cfg(not(all(
    target_arch = "wasm32",
    target_vendor = "unknown",
    target_os = "unknown"
)))]
use tokio;


## Documentation

API documentation can be found on [docs.rs](https://docs.rs/tokio_with_wasm).

## Caution

Keep in mind that you should NEVER write panicking code.

On wasm32-unknown-unknown, there's currently [no way](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.future_to_promise.html#panics) to catch and unwind panics like on native platforms. Panics will eventually lead to leaked JavaScript Promises.

Stick to the Result enum whenever possible.

## Building and Deploying

If you're using Web Workers (threads) by calling spawn_blocking, you need to set specific Rust compiler flags:

- +atomics
- +bulk-memory
- +mutable-globals

After building your webassembly module and preparing it for deployment, ensure that your web server is configured to include cross-origin-related HTTP headers in its responses. Set the [Cross-Origin-Opener-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy) to same-origin and [Cross-Origin-Embedder-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy) to require-corp. These headers enable clients using your website to gain access to SharedArrayBuffer web API, which is something similar to shared memory on the web. Additionally, don't forget to specify the MIME type application/wasm for .wasm files within the server configurations to ensure optimal performance.

## Why This is Needed

The web has many restrictions due to its sandboxed environment which prevents the use of threads, time, file IO, network IO, and many other native functionalities. Consequently, certain features are missing from Rust's std due to these limitations. That's why tokio doesn't really work well on web browsers.

To address this issue, this crate offers tokio modules with the **same names** as the original native ones, providing workarounds for these constraints.

## Future Vision

Because a large portion of Rust's web ecosystem is based on wasm32-unknown-unknown right now, we had to make an alias crate of tokio to use its functionalities directly on the web.

Hopefully, when wasm32-wasi becomes the mainstream Rust target for the web, [jco](https://github.com/bytecodealliance/jco) might be an alternative to wasm-bindgen as it can provide full std functionalities with browser shims (polyfills). However, this will take time because the [wasi-threads](https://github.com/WebAssembly/wasi-threads) proposal still has a long way to go.

Until that time, there's tokio_with_wasm!

## Contribution Guide

Contributions are always welcome! If you have any suggestions, bug reports, or want to contribute to the development of tokio_with_wasm, please open an issue or submit a pull request.

There are situations where you cannot use native Rust code directly on the web. This is because wasm32-unknown-unknown Rust target used by wasm-bindgen doesn't have a full std module. Refer to the links below to understand how to interact with JavaScript with wasm-bindgen.

- https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/js_name.html
- https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/js_namespace.html

It is possible for rust code to be called in a **web worker**. Therefore, we cannot access the global window JavaScript object
just like when you work in the main thread of JavaScript. Refer to the link below to check which web APIs are available in a web worker.
You'll be surprised by various capabilities that modern JavaScript has.

- https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers

Please note that this library uses a quite hacky and naive approach to mimic native tokio functionalities. That's because this library is regarded as a temporary solution for the period before wasm32-wasi. Any kind of PR is possible, as long as it makes things just work on the web.


-----------------------

/tokio_with_wasm_proc/src/lib.rs:
-----------------------

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn};

/// Attribute macro that mimics tokio::main.
/// This macro returns a function that simply spawns the given future
/// inside the JavaScript environment.
/// To execute the function, you might need to use
/// #[wasm_bindgen(start)] in addition to this macro.
#[proc_macro_attribute]
pub fn main(_attr: TokenStream, item: TokenStream) -> TokenStream {
    // Parse the input tokens as a function
    let input_fn = parse_macro_input!(item as ItemFn);

    // Extract function components
    let fn_name = &input_fn.sig.ident;
    let fn_args = &input_fn.sig.inputs;
    let fn_block = &input_fn.block;
    let return_type = &input_fn.sig.output;

    // Generate a non-async function
    // that calls the original function with spawn_local
    let expanded = quote! {
        fn #fn_name() {
            async fn original(#fn_args) #return_type #fn_block

            // Spawn the async function in a local task
            tokio_with_wasm::spawn_local(async {
                let _ = original().await;
            });
        }
    };

    TokenStream::from(expanded)
}